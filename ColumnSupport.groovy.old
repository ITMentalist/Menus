// utility class to build text panes of menu items to mimic two/three columns; 
// reads main.txt for any pair of 'text:=command' where := splits both; lines starting with // are comments
import javax.swing.*
import java.awt.*
import javax.swing.text.*;
import java.awt.BorderLayout
import javax.swing.BorderFactory; 
import javax.swing.border.*
import javax.swing.border.LineBorder

import static java.awt.GridBagConstraints.*
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import groovy.swing.SwingBuilder

public class ColumnSupport
{
	// holds decoded menu items filled from static loadMenu method
	def static audit = true			// true will print debug text
	def static menuLines = 0		// how many visible lines appear in the columns
	def static menuOptions = 0		// how many actual menu options appear in the columns which maybe less than menuLines if titles only
	def static menuTitle = []
	def static menuCommand = []	
	def static groovyc = []		// number of built-in commands	
	def static frameTitle="*none*";
	String propertyfile = './data/menu.properties'  		// non-OS specific parameters for business issues
    	def static config

	// keep stack of menu file names - how deep is menu layer that F12 key can use to retrace prior menu choices 
	static Storage storage			// current menu is top of the stack

	JTextPane column;			// the onscreen representation of the document			
	StyledDocument doc;			// a storage repository for text
	static SimpleAttributeSet as1;		// text decorations to apply to text within 'doc'

	// retrieve column text pane and styles with colors to be used as the menu
	public JTextPane getColumn()
	{
		return column;
	} // end of getColumn


	// retrieve pointer to array of menus
	public static getStorage()
	{
		return storage;
	} // end of getCommands


	// retrieve array of commands
	public static getCommands()
	{
		return menuCommand;
	} // end of getCommands


	// retrieve menu title for frame
	public static getFrameTitle()
	{
		return frameTitle;
	} // end of getFrameTitle


	// store menu title for frame
	public static setFrameTitle(def nt)
	{
		frameTitle = nt;
	} // end of setFrameTitle


    	// turn on auditlog listing
	public static void setAudit() {audit=true}

	
	// print debug text (maybe)
	public static void say(def text) 
	{
		if (audit) {println "$text";} 
	} // end of say


	// find text equivalent of this menu option number
	public static String getMenuCommand(int opt)
	{
		return menuCommand[opt]
	} // end of getMenuCommand

	// the maximum number of visible option lines, which might be divided into several columns
	public static int getMenuItemCount()
	{
		return menuLines 
	}

	// the highest option number assigned - the max value to key on command line before it's an error
	public static int getMenuOptionCount()
	{
		return menuOptions
	}

    	// originally had menu options and commands as part of properties file but now these are found in their own .txt file
    	// this method reloads them and divides 1st third into left column, the remainder into the middle and right columns
    	// mifilename is name of menu file to load
    	public static void loadMenu(ColumnSupport su1, ColumnSupport su2, ColumnSupport su3, String mifilename)
    	{  
    		boolean notCleared = true

    		def f = new File(mifilename)   // get handle for the menu text file
    		def words
    		def ix2=0

    		// how many menu items ?
		// signature for a menu option is text:=command
    		f.eachLine 		// walk thru each line of menu file ignoring comment lines starting with //
    		{	aline ->

			// if not a comment and line has := then split
    			if (!(aline.trim().startsWith("//")) && aline =~ /^.*\:=.*/) 		
    			{	++ix2
    				// only clear existing menu variables if this menu file has at least one := command
    				if (notCleared)
    				{       
    					notCleared=false
    					menuLines = 0
    					menuOptions = 0
    					bicNumber = []
    					menuTitle = []  	// this text is what appears on the menu panel
    					menuCommand = []	// this is the command to be executed if this option is chosen
    					setFrameTitle("$mifilename")
    				} // end of if

    				words = aline.split(/\:=/)		// break menu option into 2 parts: 1) option text description 2) option command
    				int wc = words.size()
    				def word1 = ""
    				def word2 = ""
    				boolean flag = false	// set true when the command pair form a valid command
    				int bic = 0		// set to zero unless this is an internal menu feature, a built-in command
				switch (wc)		// word count governs how it's handled
    				{
    					case 2:
    						flag = true
    						word1=words[0].trim()
    						word2=words[1].trim()
    						if ( word1.size() < 1 )
    						{
    							flag = false
    						} // end of if

    						if ( word1.size() >0 )
    						{	
    							if (word1.equals("*MENUTITLE")) {bic = 90}
    							if (word1.equals("*RED")) {bic = 1;}
    						} // end of if
    						break;

    					// a word count of one means line format was 'xxx:='  without text after :=
    					// was this for menu text only displays ?
    					case 1:
    						flag = true
    						bic = 10
    						word1=words[0].trim(); 
						say "word0=<$word1>"
    						break;
					default:
						say "unknown wc=$wc for line <${aline}>"
						bic = 99
						break;
    				} // end of switch


    				// this is a valid pair, so store
				/* need to keep all 3 collections in sync, so always update all 3 for each entry  */
    				if (flag)
    				{	
					say "  word1=<${word1}> bic=$bic";
    					bicNumber << bic

    					switch(bic)	// identify the builtin command or zero if normal menu option
    					{
    					    case 99:	break;

    					    // menu text only - not a command so allocate no number to it
    					    case 10:
	    					menuLines += 1
	    					menuTitle   << word1
	    					menuCommand << ""
    					    	break;

    					    // color sample - *RED
    					    case 1:
	    					menuLines += 1
	    					menuTitle   << word2
	    					menuCommand << ""
    					    	break;

    					    // *MENUTITLE
    					    case 90: 
    				   	   	setFrameTitle(word2) // this is a menu title not a command sequence
	    					menuTitle   << word2
	    					menuCommand << ""
    				   	   	break;

    				   	   // typical bid command of zero
    					    default:
	    					menuLines += 1
	    					menuTitle   << word1
	    					menuCommand << word2
	    					break;
    					} // end of switch

   				} // end of if

    			} // end of aLine is a menu command
    			
    		} // end of eachLine

		say ". . . found $ix2 lines and menuLines=$menuLines"


    		// do not disturb current menu if this menu file has no lines with := command identifier
    		if (notCleared) return		

    		// if the new menu name is not the same as the current menu name, then stack it
    		if (!(storage.getCurrentMenu().equals(mifilename)))
    		{
    			storage << mifilename
    		} // end of if

    		// erase each menu item column
    		su1.clearColumnText(su1)
    		su2.clearColumnText(su2)
    		su3.clearColumnText(su3)

    		// =====================================================================================================
   		// walk thru each title and place first third of menu items in column 1 and 2 with remainder in column 3
   		int i = 0;
   		int k = 0;
   		def num
   		int percolumn 
   		int[] itemcount = []
   		boolean[] itemflag = []

   		int ic = ColumnSupport.config.panelcolumns
		ic.times{itemcount << 0; itemflag << true;}

   		// with less than xxx menu items, just use a single column
   		if (menuLines < ColumnSupport.config.panelcolumns) 
   		{
   			percolumn = menuLines
   			itemcount[0] = menuLines
   		}
   		else
   		{
   			// there are enough menu items to divide between columns
   			percolumn = menuLines / ic
   			ic.times{item -> itemcount[item] = percolumn}
   			if (percolumn * ColumnSupport.config.panelcolumns != menuLines) 	// if not modulo three
   			{
   				percolumn+=1;
   				//say "even number of items per col: $percolumn";
   			} // end of if
   		} // end of else


   		say("there are ${menuLines} menu items of $percolumn items per column")
   		int thiscolumn = 0

   		// now roll thru the titles and assign them to each of the columns
   		menuTitle.each
   		{	it ->
   			say "menuTitle.each=$it and ${menuCommand[i]}"
   			i += 1;
   			say "menu $it and i=$i and bic=${bicNumber[i-1]}"
   			thiscolumn = (i - 1) / percolumn;	// compute a column number as either zero, one, two

   			num = "\n"				// give every menu item a leading c/r
			if (itemflag[thiscolumn]==true) 	// if this is the first time thru for this column, erase the leading c/r
			{
				num="";
			} // end of if

			if (bicNumber[i]<1)						// (!(menuCommand[i].equals("")))
			{
				k+=1
				if (k<10) num +=" "			// if one digit menu option number then add a leading blank
				num += "${k}. ${it}"			// logic to add a nice blank to number plus . when formatting
				menuOptions = k				// remember the maximum option number allowed to be keyed from command line
			} // end of if

			if (bicNumber[i]>1)	
			{
				num += "    ${it}"			// logic to add a nice blank to number plus . when formatting
			} // end of else


			if (!(bicNumber[i-1]==1))
			{
   			   switch(thiscolumn)			// put this menu item into a column (jtextpane)
   			   {
   				case 0 :
				su1.appendColumnText(su1,num)			// stuff in column 1
				break

   				case 1 :
				su2.appendColumnText(su2,num)			// stuff in column 2
				break

   				case 2 :
				su3.appendColumnText(su3,num)			// stuff in column 3
				break
			   } // end of switch

			   itemflag[thiscolumn] = false			// no longer first time thru
			} // end of else

   		} // end of walking thru each title 

   		int j = ( ( thiscolumn + 1 ) * percolumn ) - i		// find how many blank lines go in final column
   		say("i=$i and j=$j and thiscolumn=$thiscolumn and percolumn=$percolumn")

   		// add an extra blank m/i entry to make last column  look nicer on odd m/i count
   		j.times{ su3.appendColumnText(su3, "\n") }	

    	} // end of load


    	// ============================================
	// declare text attributes and mono font usage
	public void setColumn(ColumnSupport su)
	{
		def column1 = su.getColumn()
		column1.setBackground(Color.black);
		column1.setFocusable(false)
		column1.setEditable(false);
		column1.setFont(new Font("Monospaced", Font.PLAIN, 12));
		column1.setMinimumSize(new Dimension(250,30));
		column1.setPreferredSize(new Dimension(260,60));
		column1.setMaximumSize(new Dimension(330,120));
	} // end of setting attributes 


	// one-time setup of a column text pane and styles with colors to be used as the menu
	public JTextPane getColumnTextPane(StyledDocument document)
	{
		JTextPane jtp = new JTextPane(document);
		jtp.setBorder(null)
		return jtp;
	} // end of getText


	// test harness for this class
	public static void main(String[] args)
	{	
		say "... started"
		def frametitle = "TextPane Example"
		ColumnSupport su1 = new ColumnSupport()
		su1.clearColumnText(su1)
		ColumnSupport su2 = new ColumnSupport()
		ColumnSupport su3 = new ColumnSupport()
		ColumnSupport.loadMenu(su1,su2,su3,"./data/jim.txt")


		def c = new GridBagConstraints();	
		c.insets = new Insets(0, 1, 1, 1);
		c.weighty = 0.1;
		c.weightx = 0.0;
		c.gridx = 0; // column number where zero is first column
		c.gridy = 0; // row number where zero is first row
		c.anchor = GridBagConstraints.NORTH; // direction of drift 4 this component when smaller than window 
		c.fill = GridBagConstraints.HORIZONTAL; // rule to let a component expand both ways when more space is available on resize
		c.ipadx = 1
		c.ipady = 0
 
		JFrame.setDefaultLookAndFeelDecorated(true);
		def swing = new SwingBuilder()
		def frame = swing.frame(title:"${frametitle}", background:Color.black, pack:true, show:true, defaultCloseOperation:JFrame.EXIT_ON_CLOSE, layout:new GridLayout(3,1)) 
		{   
/* --------
		   panel(background:Color.GREEN)
		   {
			widget(menu1.getColumn())
		   } // end of panel
---------- */
		   panel(layout:new GridBagLayout(), background:Color.BLACK)
		   {
			c.weighty = 0.0;
			c.weightx = 1.0;
			//c.gridy += 0.75;  				
			c.fill = GridBagConstraints.BOTH; // HORIZONTAL

			widget(su1.getColumn(),constraints: c)
			c.gridx += 1;  				
			widget(su2.getColumn(),constraints: c)
			c.gridx += 1;
			widget(su3.getColumn(),constraints: c)
		   } // end of panel

		   panel(background:Color.RED)
		   {
			label "hi kids"
		   } // end of panel
		} // end of frame

		say "... ended"
	} // end of main


	// class constructor - loads configuration,etc.
	public ColumnSupport()
	{
		config = new ConfigSlurper().parse(new File(propertyfile).toURL())	// get non-path related static values

		// use bold green text	
		as1 = new SimpleAttributeSet()
		StyleConstants.setForeground(as1, Color.green);
		StyleConstants.setBold(as1, true);
		//StyleConstants.setItalic(as1, true);
		doc = new DefaultStyledDocument()
		column = getColumnTextPane(doc);
		clearColumnText(this)
		setColumn(this)
		storage = new Storage()
	} // end of constructor



	// This is logic to populate the joblog of the menu panel =========================
        // Clear out current document
	private void clearColumnText(ColumnSupport su) 
	{
		def column1 = su.getColumn()
		column1.setStyledDocument (doc = new DefaultStyledDocument());
	} // end of clearColumnText

	// method to add text to column pane with specific display attributes
	private void appendColumnText(ColumnSupport su, String s) 
	{
		def column1 = su.getColumn()
		doc = column1.getDocument();
		try 
		{
			doc.insertString(doc.getLength(), s, as1);
		}
		catch (BadLocationException e) {}
	} // end of appendColumnText


} // end of ColumnSupport.class

// =====================================================================================
/* spare logic from runcommand()
				//swing.p1 = support.getTitles()
			//sp.getHorizontalScrollbar().setValue(int Pos);
			//sp.getVerticalScrollbar().setValue(int Pos); 
			//JScrollBar sb = swing.sp.getHorizontalScrollbar()
			//int sph = sb.getValue()
			//int spv = swing.sp.getVerticalScrollbar().getValue()


			panel(constraints: c)  // ,opaque:true,background:Color.black)
			{
			   vbox()
			   {
				menuLines.times
				{ml -> 
					def no
					if (ml<9) 
						{no = " ${ml+1}"}
					else
						{no = "${ml+1}"}
					def mn = "${menuTitle[ml]}"
					label(id:'l${ml}',font:mono, foreground:Color.GREEN, text:"${no}. ${mn}")  // ,preferredSize:[350, 12])
				} // end of ml
			   } // end of vbox
			} // end of panel


	//Border greenline = BorderFactory.createLineBorder(Color.green,1,true);
	//Border greenline = new LineBorder(Color.green,1,true);

*/


/* ----------------
		JFrame frame = new JFrame("TextPane Example");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setLayout( new FlowLayout() )
		frame.setBackground(Color.black)
		frame.add(su1.getColumn())
		frame.setSize(800, 260);
		// report commands found
		say "... Commands are :"
		def com = []
		com = ColumnSupport.getCommands()
		com.each{cmd -> say cmd}
		//scrollPane = new JScrollPane(su2.getColumn());
		//frame.add(scrollPane);
		frame.add(su2.getColumn())
		frame.add(su3.getColumn())
		frame.pack()
		frame.setVisible(true);
------------ */

